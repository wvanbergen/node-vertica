// Generated by CoffeeScript 1.9.0
var Authentication, BackendMessage, Connection, EventEmitter, FrontendMessage, Query, errors, net, util,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __hasProp = {}.hasOwnProperty;

util = require('util');

net = require('net');

EventEmitter = require('events').EventEmitter;

FrontendMessage = require('./frontend_message');

BackendMessage = require('./backend_message');

Authentication = require('./authentication');

Query = require('./query');

errors = require('./errors');

Connection = (function(_super) {
  __extends(Connection, _super);

  function Connection(_at_connectionOptions) {
    var _base, _base1, _base2;
    this.connectionOptions = _at_connectionOptions;
    if ((_base = this.connectionOptions).host == null) {
      _base.host = 'localhost';
    }
    if ((_base1 = this.connectionOptions).port == null) {
      _base1.port = 5433;
    }
    if ((_base2 = this.connectionOptions).ssl == null) {
      _base2.ssl = 'optional';
    }
    this.connected = false;
    this.busy = true;
    this.queue = [];
    this.parameters = {};
    this.key = null;
    this.pid = null;
    this.transactionStatus = null;
    this.incomingData = new Buffer(0);
  }

  Connection.prototype.connect = function(callback) {
    var initialErrorHandler;
    this.connectedCallback = callback;
    this.connection = net.createConnection(this.connectionOptions.port, this.connectionOptions.host);
    initialErrorHandler = (function(_this) {
      return function(err) {
        if (_this.connectedCallback) {
          return _this.connectedCallback(err.message);
        } else {
          return _this.emit('error', err);
        }
      };
    })(this);
    this.connection.on('error', initialErrorHandler);
    return this.connection.on('connect', (function(_this) {
      return function() {
        _this.connection.removeListener('error', initialErrorHandler);
        _this.connected = true;
        _this._bindEventListeners();
        if (_this.connectionOptions.ssl) {
          _this._writeMessage(new FrontendMessage.SSLRequest);
          return _this.connection.once('data', function(buffer) {
            var conn, err, sslOptions;
            if ('S' === buffer.toString('utf-8')) {
              sslOptions = {
                key: _this.connectionOptions.sslKey,
                cert: _this.connectionOptions.sslCert,
                ca: _this.connectionOptions.sslCA
              };
              return conn = require('./starttls')(_this.connection, sslOptions, function() {
                var err;
                if (!conn.authorized && _this.connectionOptions.ssl === 'verified') {
                  conn.end();
                  _this.disconnect();
                  err = new errors.SSLError(conn.authorizationError);
                  if (_this.connectedCallback) {
                    return _this.connectedCallback(err);
                  } else {
                    return _this.emit('error', err);
                  }
                } else {
                  if (!conn.authorized) {
                    _this.emit('warn', conn.authorizationError);
                  }
                  _this.connection = conn;
                  _this._bindEventListeners();
                  return _this._handshake();
                }
              });
            } else if (_this.connectionOptions.ssl === "optional") {
              return _this._handshake();
            } else {
              err = new errors.SSLError("The server does not support SSL connection");
              if (_this.connectedCallback) {
                return _this.connectedCallback(err);
              } else {
                return _this.emit('error', err);
              }
            }
          });
        } else {
          return _this._handshake();
        }
      };
    })(this));
  };

  Connection.prototype._bindEventListeners = function() {
    this.connection.once('close', this._onClose.bind(this));
    this.connection.once('error', this._onError.bind(this));
    return this.connection.once('timeout', this._onTimeout.bind(this));
  };

  Connection.prototype.disconnect = function(error) {
    if (error) {
      this._onError(error);
    }
    if (this.connection.connected) {
      this._writeMessage(new FrontendMessage.Terminate());
    }
    return this.connection.end();
  };

  Connection.prototype.isSSL = function() {
    return (this.connection.pair != null) && (this.connection.encrypted != null);
  };

  Connection.prototype._scheduleJob = function(job) {
    if (this.busy) {
      this.queue.push(job);
      this.emit('queuejob', job);
    } else {
      this._runJob(job);
    }
    return job;
  };

  Connection.prototype._runJob = function(job) {
    if (!this.connected) {
      throw new errors.ClientStateError("Connection is closed");
    }
    if (this.busy) {
      throw new errors.ClientStateError("Connection is busy");
    }
    this.busy = true;
    this.currentJob = job;
    job.run();
    return job;
  };

  Connection.prototype._processJobQueue = function() {
    if (this.queue.length > 0) {
      return this._runJob(this.queue.shift());
    } else {
      return this.emit('ready', this);
    }
  };

  Connection.prototype.query = function(sql, callback) {
    return this._scheduleJob(new Query(this, sql, callback));
  };

  Connection.prototype._queryDirect = function(sql, callback) {
    return this._runJob(new Query(this, sql, callback));
  };

  Connection.prototype.copy = function(sql, source, callback) {
    var q;
    q = new Query(this, sql, callback);
    q.copyInSource = source;
    return this._scheduleJob(q);
  };

  Connection.prototype._handshake = function() {
    var authenticationFailureHandler, authenticationHandler;
    authenticationFailureHandler = (function(_this) {
      return function(err) {
        err = new errors.AuthenticationError(err);
        if (_this.connectedCallback) {
          return _this.connectedCallback(err);
        } else {
          return _this.emit('error', err);
        }
      };
    })(this);
    authenticationHandler = (function(_this) {
      return function(msg) {
        switch (msg.method) {
          case Authentication.methods.OK:
            return _this.once('ReadyForQuery', function(msg) {
              _this.removeListener('ErrorResponse', authenticationFailureHandler);
              return _this._initializeConnection();
            });
          case Authentication.methods.CLEARTEXT_PASSWORD:
          case Authentication.methods.MD5_PASSWORD:
            _this._writeMessage(new FrontendMessage.Password(_this.connectionOptions.password, msg.method, {
              salt: msg.salt,
              user: _this.connectionOptions.user
            }));
            return _this.once('Authentication', authenticationHandler);
          default:
            throw new errors.ClientStateError("Authentication method " + msg.method + " not supported.");
        }
      };
    })(this);
    this.connection.on('data', this._onData.bind(this));
    this._writeMessage(new FrontendMessage.Startup(this.connectionOptions.user, this.connectionOptions.database));
    this.once('ErrorResponse', authenticationFailureHandler);
    this.once('Authentication', authenticationHandler);
    this.on('ParameterStatus', (function(_this) {
      return function(msg) {
        return _this.parameters[msg.name] = msg.value;
      };
    })(this));
    this.on('BackendKeyData', (function(_this) {
      return function(msg) {
        var _ref;
        return _ref = [msg.pid, msg.key], _this.pid = _ref[0], _this.key = _ref[1], _ref;
      };
    })(this));
    return this.on('ReadyForQuery', (function(_this) {
      return function(msg) {
        _this.busy = false;
        _this.currentJob = false;
        return _this.transactionStatus = msg.transactionStatus;
      };
    })(this));
  };

  Connection.prototype._initializeConnection = function() {
    var chain, initializer, initializers, _i, _len;
    initializers = [];
    if (!this.connectionOptions.skipInitialization) {
      if (this.connectionOptions.interruptible) {
        initializers.push(this._initializeInterrupt);
      }
      if (this.connectionOptions.role != null) {
        initializers.push(this._initializeRoles);
      }
      if (this.connectionOptions.searchPath != null) {
        initializers.push(this._initializeSearchPath);
      }
      if (this.connectionOptions.timezone != null) {
        initializers.push(this._initializeTimezone);
      }
      if (this.connectionOptions.initializer != null) {
        initializers.push(this.connectionOptions.initializer);
      }
    }
    chain = this._initializationSuccess.bind(this);
    for (_i = 0, _len = initializers.length; _i < _len; _i++) {
      initializer = initializers[_i];
      chain = initializer.bind(this, chain, this._initializationFailure.bind(this));
    }
    return chain();
  };

  Connection.prototype._initializeRoles = function(next, fail) {
    var roles;
    roles = this.connectionOptions.role instanceof Array ? this.connectionOptions.role : [this.connectionOptions.role];
    return this._queryDirect("SET ROLE " + (roles.join(', ')), (function(_this) {
      return function(err, result) {
        if (err != null) {
          return fail(err);
        } else {
          return next();
        }
      };
    })(this));
  };

  Connection.prototype._initializeSearchPath = function(next, fail) {
    var searchPath;
    searchPath = this.connectionOptions.searchPath instanceof Array ? this.connectionOptions.searchPath : [this.connectionOptions.searchPath];
    return this._queryDirect("SET SEARCH_PATH TO " + (searchPath.join(', ')), (function(_this) {
      return function(err, result) {
        if (err != null) {
          return fail(err);
        } else {
          return next();
        }
      };
    })(this));
  };

  Connection.prototype._initializeTimezone = function(next, fail) {
    return this._queryDirect("SET TIMEZONE TO '" + this.connectionOptions.timezone + "'", (function(_this) {
      return function(err, result) {
        if (err != null) {
          return fail(err);
        } else {
          return next();
        }
      };
    })(this));
  };

  Connection.prototype._initializeInterrupt = function(next, fail) {
    return this._queryDirect("SELECT session_id FROM v_monitor.current_session", (function(_this) {
      return function(err, result) {
        if (err != null) {
          fail(err);
        }
        _this.sessionID = result.theValue();
        return next();
      };
    })(this));
  };

  Connection.prototype._initializationSuccess = function() {
    this.on('ReadyForQuery', this._processJobQueue.bind(this));
    this._processJobQueue();
    if (this.connectedCallback) {
      return this.connectedCallback(null, this);
    }
  };

  Connection.prototype._initializationFailure = function(err) {
    if (this.connectedCallback) {
      return this.connectedCallback(err);
    } else {
      return this.emit('error', err);
    }
  };

  Connection.prototype._onData = function(buffer) {
    var bufferedData, message, size;
    if (this.incomingData.length === 0) {
      this.incomingData = buffer;
    } else {
      bufferedData = new Buffer(this.incomingData.length + buffer.length);
      this.incomingData.copy(bufferedData);
      buffer.copy(bufferedData, this.incomingData.length);
      this.incomingData = bufferedData;
    }
    while (this.incomingData.length >= 5) {
      size = this.incomingData.readUInt32BE(1);
      if (size + 1 <= this.incomingData.length) {
        message = BackendMessage.fromBuffer(this.incomingData.slice(0, size + 1));
        if (this.debug) {
          console.log('<=', message.event, message);
        }
        this.emit('message', message);
        this.emit(message.event, message);
        this.incomingData = this.incomingData.slice(size + 1);
      } else {
        break;
      }
    }
    return void 0;
  };

  Connection.prototype._onClose = function() {
    var error;
    this.connected = false;
    error = new errors.ConnectionError("The connection was closed.");
    if (this.currentJob) {
      this.currentJob.onConnectionError(error);
    }
    this.currentJob = false;
    return this.emit('close');
  };

  Connection.prototype._onTimeout = function() {
    var error;
    error = new errors.ConnectionError("The connection timed out.");
    if (this.currentJob) {
      this.currentJob.onConnectionError(error);
    }
    this.currentJob = false;
    return this.emit('timeout');
  };

  Connection.prototype._onError = function(err) {
    var error, _ref;
    error = new errors.ConnectionError((_ref = err.message) != null ? _ref : err.toString());
    if (this.currentJob) {
      this.currentJob.onConnectionError(error);
    }
    this.currentJob = false;
    return this.emit('error', error);
  };

  Connection.prototype._writeMessage = function(msg, callback) {
    if (this.debug) {
      console.log('=>', msg.__proto__.constructor.name, msg);
    }
    return this.connection.write(msg.toBuffer(), callback);
  };

  Connection.prototype.isInterruptible = function() {
    return this.sessionID != null;
  };

  Connection.prototype._interruptConnection = function(cb) {
    var bareClient, bareConnectionOptions;
    if (this.sessionID != null) {
      bareConnectionOptions = {
        skipInitialization: true
      };
      bareConnectionOptions.__proto__ = this.connectionOptions;
      bareClient = new Connection(bareConnectionOptions);
      return bareClient.connect(cb);
    } else {
      return cb(new errors.ClientStateError("Cannot interrupt connection! It's not initialized as interruptible."), null);
    }
  };

  Connection.prototype._success = function(err, cb) {
    if (err != null) {
      if (cb != null) {
        cb(err);
      } else {
        this.emit('error', err);
      }
      return false;
    } else {
      return true;
    }
  };

  Connection.prototype.interruptSession = function(cb) {
    return this._interruptConnection((function(_this) {
      return function(err, conn) {
        if (_this._success(err, cb)) {
          return conn.query("SELECT CLOSE_SESSION('" + _this.sessionID + "')", function(err, rs) {
            conn.disconnect();
            if (_this._success(err, cb) && (cb != null)) {
              return cb(null, rs.theValue());
            }
          });
        }
      };
    })(this));
  };

  Connection.prototype.interruptStatement = function(cb) {
    return this._interruptConnection((function(_this) {
      return function(err, conn) {
        if (_this._success(err, cb)) {
          return conn.query("SELECT statement_id FROM v_monitor.sessions WHERE session_id = '" + _this.sessionID + "'", function(err, rs) {
            var statementID;
            if (!_this._success(err, cb)) {
              return conn.disconnect();
            } else if (rs.getLength() === 1 && (statementID = rs.theValue())) {
              return conn.query("SELECT INTERRUPT_STATEMENT('" + _this.sessionID + "', " + statementID + ")", function(err, rs) {
                conn.disconnect();
                if (_this._success(err, cb) && (cb != null)) {
                  return cb(null, rs.theValue());
                }
              });
            } else {
              conn.disconnect();
              return _this._success("Session " + _this.sessionID + " is not running a statement at the moment.", cb);
            }
          });
        }
      };
    })(this));
  };

  return Connection;

})(EventEmitter);

module.exports = Connection;
