// Generated by CoffeeScript 1.9.3
var EventEmitter, FrontendMessage, Query, Resultset, decoders, errors,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

EventEmitter = require('events').EventEmitter;

FrontendMessage = require('./frontend_message');

decoders = require('./types').decoders;

Resultset = require('./resultset');

errors = require('./errors');

Query = (function(superClass) {
  extend(Query, superClass);

  function Query(connection, sql, callback1) {
    this.connection = connection;
    this.sql = sql;
    this.callback = callback1;
    this._handlingCopyIn = false;
  }

  Query.prototype.run = function() {
    this.emit('start');
    this.connection._writeMessage(new FrontendMessage.Query(this.sql));
    this.connection.once('EmptyQueryResponse', this.onEmptyQueryListener = this.onEmptyQuery.bind(this));
    this.connection.on('RowDescription', this.onRowDescriptionListener = this.onRowDescription.bind(this));
    this.connection.on('DataRow', this.onDataRowListener = this.onDataRow.bind(this));
    this.connection.on('CommandComplete', this.onCommandCompleteListener = this.onCommandComplete.bind(this));
    this.connection.once('ErrorResponse', this.onErrorResponseListener = this.onErrorResponse.bind(this));
    this.connection.once('ReadyForQuery', this.onReadyForQueryListener = this.onReadyForQuery.bind(this));
    this.connection.once('CopyInResponse', this.onCopyInResponseListener = this.onCopyInResponse.bind(this));
    return this.connection.once('CopyFileResponse', this.onCopyFileResponseListener = this.onCopyFileResponse.bind(this));
  };

  Query.prototype.onEmptyQuery = function(msg) {
    var err;
    err = new errors.QueryError("The query was empty!");
    if (this.callback) {
      return this.error = err;
    } else {
      return this.emit('error', err);
    }
  };

  Query.prototype.onRowDescription = function(msg) {
    var column, customDecoders, decoder, field, i, len, ref, ref1, ref2, type;
    if ((this.callback != null) && (this.status != null)) {
      throw new errors.VerticaError("Cannot handle multi-queries with a callback!");
    }
    customDecoders = {};
    ref = this.connection.connectionOptions.decoders;
    for (type in ref) {
      decoder = ref[type];
      customDecoders[type] = decoder;
    }
    ref1 = this.decoders;
    for (type in ref1) {
      decoder = ref1[type];
      customDecoders[type] = decoder;
    }
    this.fields = [];
    ref2 = msg.columns;
    for (i = 0, len = ref2.length; i < len; i++) {
      column = ref2[i];
      field = new Query.Field(column, customDecoders);
      this.emit('field', field);
      this.fields.push(field);
    }
    if (this.callback) {
      this.rows = [];
    }
    return this.emit('fields', this.fields);
  };

  Query.prototype.onDataRow = function(msg) {
    var i, index, len, ref, row, value;
    row = [];
    ref = msg.values;
    for (index = i = 0, len = ref.length; i < len; index = ++i) {
      value = ref[index];
      row.push(value != null ? this.fields[index].decoder(value) : null);
    }
    if (this.callback) {
      this.rows.push(row);
    }
    return this.emit('row', row);
  };

  Query.prototype.onReadyForQuery = function(msg) {
    this._removeAllListeners();
    if (this.callback) {
      return process.nextTick((function(_this) {
        return function() {
          if (_this.error) {
            return _this.callback(_this.error);
          } else {
            return _this.callback(null, new Resultset({
              fields: _this.fields,
              rows: _this.rows,
              status: _this.status
            }));
          }
        };
      })(this));
    }
  };

  Query.prototype.onCommandComplete = function(msg) {
    if (this.callback) {
      this.status = msg.status;
    }
    return this.emit('end', msg.status);
  };

  Query.prototype.onErrorResponse = function(msg) {
    var err;
    err = new errors.QueryErrorResponse(msg);
    if (this.callback) {
      return this.error = err;
    } else {
      return this.emit('error', err);
    }
  };

  Query.prototype.onConnectionError = function(msg) {
    this._removeAllListeners();
    if (this.callback) {
      return process.nextTick((function(_this) {
        return function() {
          return _this.callback(msg);
        };
      })(this));
    } else {
      return this.emit('error', msg);
    }
  };

  Query.prototype.onCopyInResponse = function(msg) {
    var copyInHandler, dataHandler, err, failureHandler, successHandler;
    this._handlingCopyIn = true;
    dataHandler = (function(_this) {
      return function(data, callback) {
        return _this.copyData(data, callback);
      };
    })(this);
    successHandler = (function(_this) {
      return function(callback) {
        return _this.copyDone(callback);
      };
    })(this);
    failureHandler = (function(_this) {
      return function(err, callback) {
        return _this.copyFail(err, callback);
      };
    })(this);
    try {
      copyInHandler = this._getCopyInHandler();
      return copyInHandler(dataHandler, successHandler, failureHandler);
    } catch (_error) {
      err = _error;
      return this.copyFail(err);
    }
  };

  Query.prototype.onCopyFileResponse = function(msg) {
    var error;
    error = new errors.ClientStateError("COPY FROM LOCAL is not supported.");
    return this.connection.disconnect(error);
  };

  Query.prototype._getCopyInHandler = function() {
    var existsSync, fs, stream;
    if (typeof this.copyInSource === 'function') {
      return this.copyInSource;
    } else if (typeof this.copyInSource === 'string') {
      fs = require('fs');
      existsSync = fs.existsSync || require('path').existsSync;
      if (existsSync(this.copyInSource)) {
        stream = fs.createReadStream(this.copyInSource);
        return this._getStreamCopyInHandler(stream);
      } else {
        throw new errors.ClientStateError("Could not find local file " + this.copyInSource + ".");
      }
    } else if (this.copyInSource === process.stdin) {
      process.stdin.resume();
      return this._getStreamCopyInHandler(process.stdin);
    } else if (typeof this.copyInSource === 'object' && typeof this.copyInSource.read === 'function' && typeof this.copyInSource.push === 'function') {
      return this._getStreamCopyInHandler(this.copyInSource);
    } else {
      throw new errors.ClientStateError("No copy in handler defined to handle the COPY statement.");
    }
  };

  Query.prototype._getStreamCopyInHandler = function(stream) {
    return function(transfer, success, fail) {
      stream.on('data', function(data) {
        return transfer(data);
      });
      stream.on('end', function() {
        return success();
      });
      return stream.on('error', function(err) {
        return fail(err);
      });
    };
  };

  Query.prototype.copyData = function(data, callback) {
    if (this._handlingCopyIn) {
      return this.connection._writeMessage(new FrontendMessage.CopyData(data), callback);
    } else {
      throw new errors.ClientStateError("Copy in mode not active!");
    }
  };

  Query.prototype.copyDone = function(callback) {
    if (this._handlingCopyIn) {
      this.connection._writeMessage(new FrontendMessage.CopyDone(), callback);
      return this._handlingCopyIn = false;
    } else {
      throw new errors.ClientStateError("Copy in mode not active!");
    }
  };

  Query.prototype.copyFail = function(error, callback) {
    var message, ref;
    if (this._handlingCopyIn) {
      message = (ref = error.message) != null ? ref : error.toString();
      this.connection._writeMessage(new FrontendMessage.CopyFail(message), callback);
      return this._handlingCopyIn = false;
    } else {
      throw new errors.ClientStateError("Copy in mode not active!");
    }
  };

  Query.prototype._removeAllListeners = function() {
    var listeners;
    listeners = {
      'EmptyQueryResponse': this.onEmptyQueryListener,
      'RowDescription': this.onRowDescriptionListener,
      'DataRow': this.onDataRowListener,
      'CommandComplete': this.onCommandCompleteListener,
      'ErrorResponse': this.onErrorResponseListener,
      'ReadyForQuery': this.onReadyForQueryListener,
      'CopyInResponse': this.onCopyInResponseListener,
      'CopyFileResponse': this.onCopyFileResponseListener
    };
    for (var key in listeners) {
        if (typeof listeners[key] !== "undefined" && listeners[key] !== null) {
            this.connection.removeListener(key, listeners[key])
        }
    };
    return listeners;
  };

  return Query;

})(EventEmitter);

Query.Field = (function() {
  function Field(msg, customDecoders) {
    var decoder;
    this.name = msg.name;
    this.tableOID = msg.tableOID;
    this.tableFieldIndex = msg.tableFieldIndex;
    this.typeOID = msg.typeOID;
    this.type = msg.type;
    this.size = msg.size;
    this.modifier = msg.modifier;
    this.formatCode = msg.formatCode;
    if (customDecoders) {
      decoder = customDecoders[this.type] || customDecoders["default"];
    }
    this.decoder = decoder || decoders[this.formatCode][this.type] || decoders[this.formatCode]["default"];
  }

  return Field;

})();

module.exports = Query;
