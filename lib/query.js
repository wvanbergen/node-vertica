// Generated by CoffeeScript 1.9.0
var EventEmitter, FrontendMessage, Query, Resultset, decoders, errors,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __hasProp = {}.hasOwnProperty;

EventEmitter = require('events').EventEmitter;

FrontendMessage = require('./frontend_message');

decoders = require('./types').decoders;

Resultset = require('./resultset');

errors = require('./errors');

Query = (function(_super) {
  __extends(Query, _super);

  function Query(_at_connection, _at_sql, _at_callback) {
    this.connection = _at_connection;
    this.sql = _at_sql;
    this.callback = _at_callback;
    this._handlingCopyIn = false;
  }

  Query.prototype.run = function() {
    this.emit('start');
    this.connection._writeMessage(new FrontendMessage.Query(this.sql));
    this.connection.once('EmptyQueryResponse', this.onEmptyQueryListener = this.onEmptyQuery.bind(this));
    this.connection.on('RowDescription', this.onRowDescriptionListener = this.onRowDescription.bind(this));
    this.connection.on('DataRow', this.onDataRowListener = this.onDataRow.bind(this));
    this.connection.on('CommandComplete', this.onCommandCompleteListener = this.onCommandComplete.bind(this));
    this.connection.once('ErrorResponse', this.onErrorResponseListener = this.onErrorResponse.bind(this));
    this.connection.once('ReadyForQuery', this.onReadyForQueryListener = this.onReadyForQuery.bind(this));
    this.connection.once('CopyInResponse', this.onCopyInResponseListener = this.onCopyInResponse.bind(this));
    return this.connection.once('CopyFileResponse', this.onCopyFileResponseListener = this.onCopyFileResponse.bind(this));
  };

  Query.prototype.onEmptyQuery = function(msg) {
    var err;
    err = new errors.QueryError("The query was empty!");
    if (this.callback) {
      return this.error = err;
    } else {
      return this.emit('error', err);
    }
  };

  Query.prototype.onRowDescription = function(msg) {
    var column, customDecoders, decoder, err, field, type, _i, _len, _ref, _ref1, _ref2;
    if (this.status && this.callback) {
      err = new errors.VerticaError("Cannot handle multi-queries with a callback!");
      this.error = err;
      return;
    }
    customDecoders = {};
    _ref = this.connection.connectionOptions.decoders;
    for (type in _ref) {
      decoder = _ref[type];
      customDecoders[type] = decoder;
    }
    _ref1 = this.decoders;
    for (type in _ref1) {
      decoder = _ref1[type];
      customDecoders[type] = decoder;
    }
    this.fields = [];
    _ref2 = msg.columns;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      column = _ref2[_i];
      field = new Query.Field(column, customDecoders);
      this.emit('field', field);
      this.fields.push(field);
    }
    if (this.callback) {
      this.rows = [];
    }
    return this.emit('fields', this.fields);
  };

  Query.prototype.onDataRow = function(msg) {
    var index, row, value, _i, _len, _ref;
    row = [];
    _ref = msg.values;
    for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
      value = _ref[index];
      row.push(value != null ? this.fields[index].decoder(value) : null);
    }
    if (this.callback) {
      this.rows.push(row);
    }
    return this.emit('row', row);
  };

  Query.prototype.onReadyForQuery = function(msg) {
    this._removeAllListeners();
    if (this.callback) {
      return process.nextTick((function(_this) {
        return function() {
          if (_this.error) {
            return _this.callback(_this.error);
          } else {
            return _this.callback(null, new Resultset({
              fields: _this.fields,
              rows: _this.rows,
              status: _this.status
            }));
          }
        };
      })(this));
    }
  };

  Query.prototype.onCommandComplete = function(msg) {
    if (this.callback) {
      this.status = msg.status;
    }
    return this.emit('end', msg.status);
  };

  Query.prototype.onErrorResponse = function(msg) {
    var err;
    err = new errors.QueryErrorResponse(msg);
    if (this.callback) {
      return this.error = err;
    } else {
      return this.emit('error', err);
    }
  };

  Query.prototype.onConnectionError = function(msg) {
    this._removeAllListeners();
    if (this.callback) {
      return process.nextTick((function(_this) {
        return function() {
          return _this.callback(msg);
        };
      })(this));
    } else {
      return this.emit('error', msg);
    }
  };

  Query.prototype.onCopyInResponse = function(msg) {
    var copyInHandler, dataHandler, err, failureHandler, successHandler;
    this._handlingCopyIn = true;
    dataHandler = (function(_this) {
      return function(data, callback) {
        return _this.copyData(data, callback);
      };
    })(this);
    successHandler = (function(_this) {
      return function(callback) {
        return _this.copyDone(callback);
      };
    })(this);
    failureHandler = (function(_this) {
      return function(err, callback) {
        return _this.copyFail(err, callback);
      };
    })(this);
    try {
      copyInHandler = this._getCopyInHandler();
      return copyInHandler(dataHandler, successHandler, failureHandler);
    } catch (_error) {
      err = _error;
      return this.copyFail(err);
    }
  };

  Query.prototype.onCopyFileResponse = function(msg) {
    var error;
    error = new errors.ClientStateError("COPY FROM LOCAL is not supported.");
    return this.connection.disconnect(error);
  };

  Query.prototype._getCopyInHandler = function() {
    var existsSync, fs, stream;
    if (typeof this.copyInSource === 'function') {
      return this.copyInSource;
    } else if (typeof this.copyInSource === 'string') {
      fs = require('fs');
      existsSync = fs.existsSync || require('path').existsSync;
      if (existsSync(this.copyInSource)) {
        stream = fs.createReadStream(this.copyInSource);
        return this._getStreamCopyInHandler(stream);
      } else {
        throw new errors.ClientStateError("Could not find local file " + this.copyInSource + ".");
      }
    } else if (this.copyInSource === process.stdin) {
      process.stdin.resume();
      return this._getStreamCopyInHandler(process.stdin);
    } else if (typeof this.copyInSource === 'object' && typeof this.copyInSource.read === 'function' && typeof this.copyInSource.push === 'function') {
      return this._getStreamCopyInHandler(this.copyInSource);
    } else {
      throw new errors.ClientStateError("No copy in handler defined to handle the COPY statement.");
    }
  };

  Query.prototype._getStreamCopyInHandler = function(stream) {
    return function(transfer, success, fail) {
      stream.on('data', function(data) {
        return transfer(data);
      });
      stream.on('end', function() {
        return success();
      });
      return stream.on('error', function(err) {
        return fail(err);
      });
    };
  };

  Query.prototype.copyData = function(data, callback) {
    if (this._handlingCopyIn) {
      return this.connection._writeMessage(new FrontendMessage.CopyData(data), callback);
    } else {
      throw new errors.ClientStateError("Copy in mode not active!");
    }
  };

  Query.prototype.copyDone = function(callback) {
    if (this._handlingCopyIn) {
      this.connection._writeMessage(new FrontendMessage.CopyDone(), callback);
      return this._handlingCopyIn = false;
    } else {
      throw new errors.ClientStateError("Copy in mode not active!");
    }
  };

  Query.prototype.copyFail = function(error, callback) {
    var message, _ref;
    if (this._handlingCopyIn) {
      message = (_ref = error.message) != null ? _ref : error.toString();
      this.connection._writeMessage(new FrontendMessage.CopyFail(message), callback);
      return this._handlingCopyIn = false;
    } else {
      throw new errors.ClientStateError("Copy in mode not active!");
    }
  };

  Query.prototype._removeAllListeners = function() {
    this.connection.removeListener('EmptyQueryResponse', this.onEmptyQueryListener);
    this.connection.removeListener('RowDescription', this.onRowDescriptionListener);
    this.connection.removeListener('DataRow', this.onDataRowListener);
    this.connection.removeListener('CommandComplete', this.onCommandCompleteListener);
    this.connection.removeListener('ErrorResponse', this.onErrorResponseListener);
    this.connection.removeListener('ReadyForQuery', this.onReadyForQueryListener);
    this.connection.removeListener('CopyInResponse', this.onCopyInResponseListener);
    return this.connection.removeListener('CopyFileResponse', this.onCopyFileResponseListener);
  };

  return Query;

})(EventEmitter);

Query.Field = (function() {
  function Field(msg, customDecoders) {
    var decoder;
    this.name = msg.name;
    this.tableOID = msg.tableOID;
    this.tableFieldIndex = msg.tableFieldIndex;
    this.typeOID = msg.typeOID;
    this.type = msg.type;
    this.size = msg.size;
    this.modifier = msg.modifier;
    this.formatCode = msg.formatCode;
    if (customDecoders) {
      decoder = customDecoders[this.type] || customDecoders["default"];
    }
    this.decoder = decoder || decoders[this.formatCode][this.type] || decoders[this.formatCode]["default"];
  }

  return Field;

})();

module.exports = Query;
