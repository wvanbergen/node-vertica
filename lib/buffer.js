// Generated by CoffeeScript 1.6.2
(function() {
  var Buffer, _base, _base1, _base2, _base3, _base4, _base5, _base6, _base7, _base8, _base9, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;

  Buffer = require('buffer').Buffer;

  if ((_ref = (_base = Buffer.prototype).writeUInt8) == null) {
    _base.writeUInt8 = function(number, offset) {
      this[offset] = number & 0xff;
      return void 0;
    };
  }

  if ((_ref1 = (_base1 = Buffer.prototype).writeUInt16) == null) {
    _base1.writeUInt16 = function(number, offset, endian) {
      return this._writeUInt(2, number, offset, endian);
    };
  }

  if ((_ref2 = (_base2 = Buffer.prototype).writeUInt32) == null) {
    _base2.writeUInt32 = function(number, offset, endian) {
      return this._writeUInt(4, number, offset, endian);
    };
  }

  if ((_ref3 = (_base3 = Buffer.prototype)._writeUInt) == null) {
    _base3._writeUInt = function(bytes, number, offset, endian) {
      var currentOffset, encodingPositions, index, _i, _j, _k, _len, _ref4, _ref5, _results, _results1;

      encodingPositions = endian === 'little' ? (function() {
        _results = [];
        for (var _i = offset, _ref4 = offset + bytes - 1; offset <= _ref4 ? _i <= _ref4 : _i >= _ref4; offset <= _ref4 ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this) : (function() {
        _results1 = [];
        for (var _j = _ref5 = offset + bytes - 1; _ref5 <= offset ? _j <= offset : _j >= offset; _ref5 <= offset ? _j++ : _j--){ _results1.push(_j); }
        return _results1;
      }).apply(this);
      for (index = _k = 0, _len = encodingPositions.length; _k < _len; index = ++_k) {
        currentOffset = encodingPositions[index];
        this[currentOffset] = (number >> (8 * index)) & 0xff;
      }
      return void 0;
    };
  }

  if ((_ref4 = (_base4 = Buffer.prototype).writeZeroTerminatedString) == null) {
    _base4.writeZeroTerminatedString = function(str, offset, encoding) {
      var written;

      written = this.write(str, offset, null, encoding);
      this.writeUInt8(0, offset + written);
      return written + 1;
    };
  }

  if ((_ref5 = (_base5 = Buffer.prototype).readUInt8) == null) {
    _base5.readUInt8 = function(offset) {
      return this[offset];
    };
  }

  if ((_ref6 = (_base6 = Buffer.prototype).readUInt16) == null) {
    _base6.readUInt16 = function(offset, endian) {
      return this._readUInt(2, offset, endian);
    };
  }

  if ((_ref7 = (_base7 = Buffer.prototype).readUInt32) == null) {
    _base7.readUInt32 = function(offset, endian) {
      return this._readUInt(4, offset, endian);
    };
  }

  if ((_ref8 = (_base8 = Buffer.prototype)._readUInt) == null) {
    _base8._readUInt = function(bytes, offset, endian) {
      var currentOffset, encodingPositions, index, number, _i, _j, _k, _len, _ref10, _ref9, _results, _results1;

      encodingPositions = endian === 'little' ? (function() {
        _results = [];
        for (var _i = offset, _ref9 = offset + bytes - 1; offset <= _ref9 ? _i <= _ref9 : _i >= _ref9; offset <= _ref9 ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this) : (function() {
        _results1 = [];
        for (var _j = _ref10 = offset + bytes - 1; _ref10 <= offset ? _j <= offset : _j >= offset; _ref10 <= offset ? _j++ : _j--){ _results1.push(_j); }
        return _results1;
      }).apply(this);
      number = 0;
      for (index = _k = 0, _len = encodingPositions.length; _k < _len; index = ++_k) {
        currentOffset = encodingPositions[index];
        number = (this[currentOffset] << (index * 8)) | number;
      }
      return number;
    };
  }

  if ((_ref9 = (_base9 = Buffer.prototype).readZeroTerminatedString) == null) {
    _base9.readZeroTerminatedString = function(offset, encoding) {
      var endIndex;

      endIndex = offset;
      while (endIndex < this.length && this[endIndex] !== 0x00) {
        endIndex++;
      }
      return this.toString('ascii', offset, endIndex);
    };
  }

  exports.Buffer = Buffer;

}).call(this);
